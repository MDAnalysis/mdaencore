


  


<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="shortcut icon" href="_static/logo/mda_favicon.ico">
</head>

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mdaencore.similarity &mdash; mdaencore  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/site.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../_static/js/versions.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="mdaencore.utils" href="mdaencore.utils.html" />
    <link rel="prev" title="mdaencore.dimensionality_reduction.stochasticproxembed" href="mdaencore.dimensionality_reduction.stochasticproxembed.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >



  



<a href="../index.html">
  
    <img src="_static/logo/mda_logo.png" class="logo" alt="Logo"/>
</a>


  
  
  



<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="mdaencore.html">mdaencore</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="mdaencore.bootstrap.html">mdaencore.bootstrap</a></li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.clustering.html">mdaencore.clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.confdistmatrix.html">mdaencore.confdistmatrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.covariance.html">mdaencore.covariance</a></li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.cutils.html">mdaencore.cutils</a></li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.data.html">mdaencore.data</a></li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.dimensionality_reduction.html">mdaencore.dimensionality_reduction</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">mdaencore.similarity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ensemble-similarity-calculations-mdaencore-similarity">Ensemble Similarity Calculations — <code class="xref py py-mod docutils literal notranslate"><span class="pre">mdaencore.similarity</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="mdaencore.utils.html">mdaencore.utils</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">mdaencore</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api.html">API Documentation</a></li>
          <li class="breadcrumb-item"><a href="mdaencore.html">mdaencore</a></li>
      <li class="breadcrumb-item active">mdaencore.similarity</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/autosummary/mdaencore.similarity.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-mdaencore.similarity">
<span id="mdaencore-similarity"></span><h1>mdaencore.similarity<a class="headerlink" href="#module-mdaencore.similarity" title="Permalink to this heading"></a></h1>
<section id="ensemble-similarity-calculations-mdaencore-similarity">
<h2>Ensemble Similarity Calculations — <a class="reference internal" href="#module-mdaencore.similarity" title="mdaencore.similarity"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mdaencore.similarity</span></code></a><a class="headerlink" href="#ensemble-similarity-calculations-mdaencore-similarity" title="Permalink to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Matteo Tiberti, Wouter Boomsma, Tone Bengtsen</p>
</dd>
</dl>
<p>The module contains implementations of similarity measures between protein
ensembles described in <span id="id1">[<a class="reference internal" href="#id8" title="Kresten Lindorff-Larsen and Jesper Ferkinghoff-Borg. Similarity measures for protein ensembles. PLOS ONE, 4(1):1-13, 01 2009. doi:10.1371/journal.pone.0004203.">ᵇLLFB09</a>]</span>. The implementation and
examples are described in <span id="id2">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p>
<p>The module includes facilities for handling ensembles and trajectories through
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Universe</span></code> class, performing clustering or dimensionality reduction
of the ensemble space, estimating multivariate probability distributions from
the input data, and more. ENCORE can be used to compare experimental and
simulation-derived ensembles, as well as estimate the convergence of
trajectories from time-dependent simulations.</p>
<p>ENCORE includes three different methods for calculations of similarity measures
between ensembles implemented in individual functions:</p>
<ul class="simple">
<li><p><strong>Harmonic Ensemble Similarity</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">hes()</span></code></p></li>
<li><p><strong>Clustering Ensemble Similarity</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">ces()</span></code></p></li>
<li><p><strong>Dimensional Reduction Ensemble Similarity</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">dres()</span></code></p></li>
</ul>
<p>as well as two methods to evaluate the convergence of trajectories:</p>
<ul class="simple">
<li><p><strong>Clustering based convergence evaluation</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">ces_convergence()</span></code></p></li>
<li><p><strong>Dimensionality-reduction based convergence evaluation</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">dres_convergence()</span></code></p></li>
</ul>
<p>When using this module in published work please cite <span id="id3">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p>
<p class="rubric" id="examples">Examples</p>
<p>The examples show how to use ENCORE to calculate a similarity measurement
of two simple ensembles. The ensembles are obtained from the MDAnalysis
test suite for two different simulations of the protein AdK.</p>
<p>To calculate the Harmonic Ensemble Similarity (<code class="xref py py-func docutils literal notranslate"><span class="pre">hes()</span></code>)
two ensemble objects are first created and then used for calculation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">HES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">hes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">HES</span><span class="p">)</span>
<span class="go">[[       0.         38279540.04524205]</span>
<span class="go"> [38279540.04524205        0.        ]]</span>
</pre></div>
</div>
<p>HES can assume any non-negative value, i.e. no upper bound exists and the
measurement can therefore be used as an absolute scale.</p>
<p>The calculation of the Clustering Ensemble Similarity (<code class="xref py py-func docutils literal notranslate"><span class="pre">ces()</span></code>)
is computationally more expensive. It is based on clustering algorithms that in
turn require a similarity matrix between the frames the ensembles are made
of. The similarity matrix is derived from a distance matrix (By default a RMSD
matrix; a full RMSD matrix between each pairs of elements needs to be computed).
The RMSD matrix is automatically calculated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">ces</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">CES</span><span class="p">)</span>
<span class="go">[[0.         0.68070702]</span>
<span class="go"> [0.68070702 0.        ]]</span>
</pre></div>
</div>
<p>The RMSD matrix can also be separately calculated to reuse it, e.g. for running
CES with different parameters or running the
Dimensional Reduction Ensemble Similarity (<code class="xref py py-func docutils literal notranslate"><span class="pre">dres()</span></code>) method.
DRES is based on the estimation of the probability density in
a dimensionally-reduced conformational space of the ensembles, obtained from
the original space using either the Stochastic Proximity Embedding algorithm or
the Principal Component Analysis.
In the following example the dimensions are reduced to 3 using the
RMSD matrix and the default SPE dimensional reduction method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rmsd_matrix</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">get_distance_matrix</span><span class="p">(</span>
<span class="gp">... </span>                            <span class="n">encore</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">merge_universes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DRES</span><span class="p">,</span><span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">dres</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">rmsd_matrix</span><span class="p">)</span>
</pre></div>
</div>
<p>The RMSD matrix can also be saved on disk with the option <code class="docutils literal notranslate"><span class="pre">save_matrix</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rmsd_matrix</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">get_distance_matrix</span><span class="p">(</span>
                                <span class="n">encore</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">merge_universes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">]),</span>
                                <span class="n">save_matrix</span><span class="o">=</span><span class="s2">&quot;rmsd.npz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It can then be loaded and reused at a later time instead of being recalculated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rmsd_matrix</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">get_distance_matrix</span><span class="p">(</span>
                                <span class="n">encore</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">merge_universes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">]),</span>
                                <span class="n">load_matrix</span><span class="o">=</span><span class="s2">&quot;rmsd.npz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the quantitative similarity estimate, the dimensional reduction
can easily be visualized, see the <code class="docutils literal notranslate"><span class="pre">Example</span></code> section in
<a class="reference internal" href="mdaencore.dimensionality_reduction.reduce_dimensionality.html#module-mdaencore.dimensionality_reduction.reduce_dimensionality" title="mdaencore.dimensionality_reduction.reduce_dimensionality"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mdaencore.dimensionality_reduction.reduce_dimensionality</span></code></a>.
Due to the stochastic nature of SPE, two identical ensembles will not
necessarily result in an exactly 0 estimate of the similarity, but will be very
close. For the same reason, calculating the similarity with the <code class="xref py py-func docutils literal notranslate"><span class="pre">dres()</span></code>
twice will not result in necessarily identical values but rather two very close
values.</p>
<p>It should be noted that both in <code class="xref py py-func docutils literal notranslate"><span class="pre">ces()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">dres()</span></code> the similarity is
evaluated using the Jensen-Shannon divergence resulting in an upper bound of
ln(2), which indicates no similarity between the ensembles and a lower bound
of 0.0 signifying two identical ensembles. In contrast, the <code class="xref py py-func docutils literal notranslate"><span class="pre">hes()</span></code> function uses
a symmetrized version of the Kullback-Leibler divergence, which is unbounded.</p>
<section id="functions-for-ensemble-comparisons">
<h3>Functions for ensemble comparisons<a class="headerlink" href="#functions-for-ensemble-comparisons" title="Permalink to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">mdaencore.similarity.</span></span><span class="sig-name descname"><span class="pre">hes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensembles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">select</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'name</span> <span class="pre">CA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'shrinkage'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mass'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">align</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrapping_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_diagonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdaencore/similarity.html#hes"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculates the Harmonic Ensemble Similarity (HES) between ensembles.</p>
<p>The HES is calculated with the symmetrized version of Kullback-Leibler
divergence as described in <span id="id4">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensembles</strong> (<em>list</em>) – List of Universe objects for similarity measurements.</p></li>
<li><p><strong>select</strong> (<em>str, optional</em>) – Atom selection string in the MDAnalysis format. Default is “name CA”</p></li>
<li><p><strong>cov_estimator</strong> (<em>str, optional</em>) – Covariance matrix estimator method, either shrinkage, <cite>shrinkage</cite>,
or Maximum Likelyhood, <cite>ml</cite>. Default is shrinkage.</p></li>
<li><p><strong>weights</strong> (<em>str/array_like, optional</em>) – specify optional weights. If <code class="docutils literal notranslate"><span class="pre">mass</span></code> then chose masses of ensemble atoms</p></li>
<li><p><strong>align</strong> (<em>bool, optional</em>) – Whether to align the ensembles before calculating their similarity.
Note: this changes the ensembles in-place, and will thus leave your
ensembles in an altered state.
(default is False)</p></li>
<li><p><strong>estimate_error</strong> (<em>bool, optional</em>) – Whether to perform error estimation (default is False).</p></li>
<li><p><strong>bootstrapping_samples</strong> (<em>int, optional</em>) – Number of times the similarity matrix will be bootstrapped (default
is 100), only if estimate_error is True.</p></li>
<li><p><strong>calc_diagonal</strong> (<em>bool, optional</em>) – Whether to calculate the diagonal of the similarity scores
(i.e. the similarities of every ensemble against itself).
If this is False (default), 0.0 will be used instead.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>hes, details</strong> – Harmonic similarity measurements between each pair of ensembles,
and dict containing mean and covariance matrix for each ensemble</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array, dictionary</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method assumes that each ensemble is derived from a multivariate normal
distribution. The mean and covariance matrix are, thus, estimatated from
the distribution of each ensemble and used for comparision by the
symmetrized version of Kullback-Leibler divergence defined as:</p>
<div class="math notranslate nohighlight">
\[D_{KL}(P(x) || Q(x)) =
    \int_{-\infty}^{\infty}P(x_i) ln(P(x_i)/Q(x_i)) =
    \langle{}ln(P(x))\rangle{}_P - \langle{}ln(Q(x))\rangle{}_P\]</div>
<p>where the <span class="math notranslate nohighlight">\(\langle{}.\rangle{}_P\)</span> denotes an expectation
calculated under the distribution <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>For each ensemble, the  mean conformation is estimated as the average over
the ensemble, and the covariance matrix is calculated by default using a
shrinkage estimation method (or by a maximum-likelihood method,
optionally).</p>
<p>Note that the symmetrized version of the Kullback-Leibler divergence has no
upper bound (unlike the Jensen-Shannon divergence used by for instance CES and DRES).</p>
<p>When using this similarity measure, consider whether you want to align
the ensembles first (see example below).</p>
<p class="rubric">Example</p>
<p>To calculate the Harmonic Ensemble similarity, two ensembles are created
as Universe objects from a topology file and two trajectories. The
topology- and trajectory files used are obtained from the MDAnalysis
test suite for two different simulations of the protein AdK.
You can use the <code class="docutils literal notranslate"><span class="pre">align=True</span></code> option to align the ensembles first. This will
align everything to the current timestep in the first ensemble. Note that
this changes the <code class="docutils literal notranslate"><span class="pre">ens1</span></code> and <code class="docutils literal notranslate"><span class="pre">ens2</span></code> objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">HES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">hes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">HES</span><span class="p">)</span>
<span class="go">[[       0.         38279540.04524205]</span>
<span class="go"> [38279540.04524205        0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">encore</span><span class="o">.</span><span class="n">hes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">],</span> <span class="n">align</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[[   0.         6889.89729056]</span>
<span class="go"> [6889.89729056    0.        ]]</span>
</pre></div>
</div>
<p>Alternatively, for greater flexibility in how the alignment should be done
you can call use an <a class="reference external" href="https://docs.mdanalysis.org/stable/documentation_pages/analysis/align.html#MDAnalysis.analysis.align.AlignTraj" title="(in MDAnalysis v2.6.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlignTraj</span></code></a> object
manually:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.analysis</span> <span class="kn">import</span> <span class="n">align</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">align</span><span class="o">.</span><span class="n">AlignTraj</span><span class="p">(</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens1</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s2">&quot;name CA&quot;</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">align</span><span class="o">.</span><span class="n">AlignTraj</span><span class="p">(</span><span class="n">ens2</span><span class="p">,</span> <span class="n">ens1</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s2">&quot;name CA&quot;</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">encore</span><span class="o">.</span><span class="n">hes</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[[   0.         6889.89729056]</span>
<span class="go"> [6889.89729056    0.        ]]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.0.0: </span><code class="docutils literal notranslate"><span class="pre">hes</span></code> doesn’t accept the <cite>details</cite> argument anymore, it always returns
the details of the calculation instead, in the form of a dictionary</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">mdaencore.similarity.</span></span><span class="sig-name descname"><span class="pre">ces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensembles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">select='name</span> <span class="pre">CA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clustering_method=&lt;mdaencore.clustering.ClusteringMethod.AffinityPropagationNative</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_error=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrapping_samples=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncores=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_diagonal=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_collapsed_result=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdaencore/similarity.html#ces"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculates the Clustering Ensemble Similarity (CES) between ensembles
using the Jensen-Shannon divergence as described in
<span id="id5">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensembles</strong> (<em>list</em>) – List of ensemble objects for similarity measurements</p></li>
<li><p><strong>select</strong> (<em>str, optional</em>) – Atom selection string in the MDAnalysis format. Default is “name CA”</p></li>
<li><p><strong>clustering_method</strong> – A single or a list of instances of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">MDAnalysis.analysis.encore.clustering.ClusteringMethod</span></code> classes
from the clustering module. Different parameters for the same clustering
method can be explored by adding different instances of the same
clustering class. Clustering methods options are the
Affinity Propagation (default), the DBSCAN and the KMeans. The latter
two methods need the sklearn python module installed.</p></li>
<li><p><strong>distance_matrix</strong> (<em>encore.utils.TriangularMatrix</em>) – Distance matrix clustering methods. If this parameter
is not supplied the matrix will be calculated on the fly.</p></li>
<li><p><strong>estimate_error</strong> (<em>bool, optional</em>) – Whether to perform error estimation (default is False).
Only bootstrapping mode is supported.</p></li>
<li><p><strong>bootstrapping_samples</strong> (<em>int, optional</em>) – number of samples to be used for estimating error.</p></li>
<li><p><strong>ncores</strong> (<em>int, optional</em>) – Maximum number of cores to be used (default is 1).</p></li>
<li><p><strong>calc_diagonal</strong> (<em>bool, optional</em>) – Whether to calculate the diagonal of the similarity scores
(i.e. the similarities of every ensemble against itself).
If this is False (default), 0.0 will be used instead.</p></li>
<li><p><strong>allow_collapsed_result</strong> (<em>bool, optional</em>) – Whether a return value of a list of one value should be collapsed
into just the value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>ces, details</strong> – ces contains the similarity values, arranged in a numpy.array.
If only one clustering_method is provided the output will be a
2-dimensional square symmetrical numpy.array. The order of the matrix
elements depends on the order of the input ensembles: for instance, if</p>
<blockquote>
<div><p>ensemble = [ens1, ens2, ens3]</p>
</div></blockquote>
<p>the matrix elements [0,2] and [2,0] will both contain the similarity
value between ensembles ens1 and ens3.
Elaborating on the previous example, if <em>n</em> ensembles are given and <em>m</em>
clustering_methods are provided the output will be a list of <em>m</em> arrays
ordered by the input sequence of methods, each with a <em>n*x*n</em>
symmetrical similarity matrix.</p>
<p>details contains information on the clustering: the individual size of
each cluster, the centroids and the frames associated with each cluster.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array, numpy.array</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In the Jensen-Shannon divergence the upper bound of ln(2) signifies
no similarity between the two ensembles, the lower bound, 0.0,
signifies identical ensembles.</p>
<p>To calculate the CES, the affinity propagation method (or others, if
specified) is used to partition the whole space of conformations. The
population of each ensemble in each cluster is then taken as a probability
density function. Different probability density functions from each
ensemble are finally compared using the Jensen-Shannon divergence measure.</p>
<p class="rubric">Examples</p>
<p>To calculate the Clustering Ensemble similarity, two ensembles are
created as Universe object using a topology file and two trajectories. The
topology- and trajectory files used are obtained from the MDAnalysis
test suite for two different simulations of the protein AdK.
To use a different clustering method, set the parameter clustering_method
(Note that the sklearn module must be installed). Likewise, different parameters
for the same clustering method can be explored by adding different
instances of the same clustering class.
Here the simplest case of just two instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">Universe</span></code> is illustrated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span> <span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">ces</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span><span class="n">ens2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">CES</span><span class="p">)</span>
<span class="go">[[0.         0.68070702]</span>
<span class="go"> [0.68070702 0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">ces</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span><span class="n">ens2</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="n">clustering_method</span> <span class="o">=</span> <span class="p">[</span><span class="n">encore</span><span class="o">.</span><span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mf">0.45</span><span class="p">),</span>
<span class="gp">... </span>                                               <span class="n">encore</span><span class="o">.</span><span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mf">0.50</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;eps=0.45: &quot;</span><span class="p">,</span> <span class="n">CES</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">eps=0.45:  [[0.         0.20447236]</span>
<span class="go"> [0.20447236 0.        ]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;eps=0.5: &quot;</span><span class="p">,</span> <span class="n">CES</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">eps=0.5:  [[0.         0.25331629]</span>
<span class="go"> [0.25331629 0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">mdaencore.similarity.</span></span><span class="sig-name descname"><span class="pre">dres</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensembles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">select='name</span> <span class="pre">CA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality_reduction_method=&lt;mdaencore.dimensionality_reduction.DimensionalityReductionMethod.StochasticProximityEmbeddingNative</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_matrix=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsamples=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_error=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrapping_samples=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncores=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_diagonal=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_collapsed_result=True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdaencore/similarity.html#dres"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Calculates the Dimensional Reduction Ensemble Similarity (DRES) between
ensembles using the Jensen-Shannon divergence as described in
<span id="id6">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensembles</strong> (<em>list</em>) – List of ensemble objects for similarity measurements</p></li>
<li><p><strong>select</strong> (<em>str, optional</em>) – Atom selection string in the MDAnalysis format. Default is “name CA”</p></li>
<li><p><strong>dimensionality_reduction_method</strong> – A single or a list of instances of the DimensionalityReductionMethod
classes from the dimensionality_reduction module. Different parameters
for the same method can be explored by adding different instances of
the same dimensionality reduction class. Provided methods are the
Stochastic Proximity Embedding (default) and the Principal Component
Analysis.</p></li>
<li><p><strong>distance_matrix</strong> (<em>encore.utils.TriangularMatrix</em>) – conformational distance matrix, It will be calculated on the fly
from the ensemble data if it is not provided.</p></li>
<li><p><strong>nsamples</strong> (<em>int, optional</em>) – Number of samples to be drawn from the ensembles (default is 1000).
This is used to resample the density estimates and calculate the
Jensen-Shannon divergence between ensembles.</p></li>
<li><p><strong>estimate_error</strong> (<em>bool, optional</em>) – Whether to perform error estimation (default is False)</p></li>
<li><p><strong>bootstrapping_samples</strong> (<em>int, optional</em>) – number of samples to be used for estimating error.</p></li>
<li><p><strong>ncores</strong> (<em>int, optional</em>) – Maximum number of cores to be used (default is 1).</p></li>
<li><p><strong>calc_diagonal</strong> (<em>bool, optional</em>) – Whether to calculate the diagonal of the similarity scores
(i.e. the simlarities of every ensemble against itself).
If this is False (default), 0.0 will be used instead.</p></li>
<li><p><strong>allow_collapsed_result</strong> (<em>bool, optional</em>) – Whether a return value of a list of one value should be collapsed
into just the value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>dres, details</strong> – dres contains the similarity values, arranged in numpy.array.
If one number of dimensions is provided as an integer,
the output will be a 2-dimensional square symmetrical numpy.array.
The order of the matrix elements depends on the order of the
input ensemble: for instance, if</p>
<blockquote>
<div><p>ensemble = [ens1, ens2, ens3]</p>
</div></blockquote>
<p>then the matrix elements [0,2] and [2,0] will both contain the
similarity value between ensembles ens1 and ens3.
Elaborating on the previous example, if <em>n</em> ensembles are given and <em>m</em>
methods are provided the output will be a list of <em>m</em> arrays
ordered by the input sequence of methods, each with a <em>n*x*n</em>
symmetrical similarity matrix.</p>
<p>details provide an array of the reduced_coordinates.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array, numpy.array</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To calculate the similarity, the method first projects the ensembles into
lower dimensions by using the Stochastic Proximity Embedding (or others)
algorithm. A gaussian kernel-based density estimation method is then used
to estimate the probability density for each ensemble which is then used
to compute the Jensen-Shannon divergence between each pair of ensembles.</p>
<p>In the Jensen-Shannon divergence the upper bound of ln(2) signifies
no similarity between the two ensembles, the lower bound, 0.0,
signifies identical ensembles. However, due to the stochastic nature of
the dimensional reduction in <code class="xref py py-func docutils literal notranslate"><span class="pre">dres()</span></code>, two identical ensembles will
not necessarily result in an exact 0.0 estimate of the similarity but
will be very close. For the same reason, calculating the similarity with
the <code class="xref py py-func docutils literal notranslate"><span class="pre">dres()</span></code> twice will not result in two identical numbers; small
differences have to be expected.</p>
<p class="rubric">Examples</p>
<p>To calculate the Dimensional Reduction Ensemble similarity, two ensembles
are created as Universe objects from a topology file and two trajectories.
The topology- and trajectory files used are obtained from the MDAnalysis
test suite for two different simulations of the protein AdK.
To use a different dimensional reduction methods, simply set the
parameter dimensionality_reduction_method. Likewise, different parameters
for the same clustering method can be explored by adding different
instances of the same method  class.
Here the simplest case of comparing just two instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">Universe</span></code> is
illustrated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">Universe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">MDAnalysis.analysis.encore</span> <span class="k">as</span> <span class="nn">encore</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">MDAnalysis.tests.datafiles</span> <span class="kn">import</span> <span class="n">PSF</span><span class="p">,</span> <span class="n">DCD</span><span class="p">,</span> <span class="n">DCD2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens1</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span><span class="n">DCD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ens2</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">PSF</span><span class="p">,</span><span class="n">DCD2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DRES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">dres</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span><span class="n">ens2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PCA_method</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">PrincipalComponentAnalysis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DRES</span><span class="p">,</span> <span class="n">details</span> <span class="o">=</span> <span class="n">encore</span><span class="o">.</span><span class="n">dres</span><span class="p">([</span><span class="n">ens1</span><span class="p">,</span><span class="n">ens2</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="n">dimensionality_reduction_method</span><span class="o">=</span><span class="n">PCA_method</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the quantitative similarity estimate, the dimensional
reduction can easily be visualized, see the <code class="docutils literal notranslate"><span class="pre">Example</span></code> section in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">mdaencore.dimensionality_reduction.reduce_dimensionality`</span></code></p>
</dd></dl>

</section>
<section id="function-reference">
<h3>Function reference<a class="headerlink" href="#function-reference" title="Permalink to this heading"></a></h3>
<p class="rubric">References</p>
<div class="docutils container" id="id7">
<div class="citation" id="id8" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">ᵇLLFB09</a><span class="fn-bracket">]</span></span>
<p>Kresten Lindorff-Larsen and Jesper Ferkinghoff-Borg. Similarity measures for protein ensembles. <em>PLOS ONE</em>, 4(1):1–13, 01 2009. <a class="reference external" href="https://doi.org/10.1371/journal.pone.0004203">doi:10.1371/journal.pone.0004203</a>.</p>
</div>
<div class="citation" id="id9" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ᵇTPB+15<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id4">3</a>,<a role="doc-backlink" href="#id5">4</a>,<a role="doc-backlink" href="#id6">5</a>,<a role="doc-backlink" href="#id1">6</a>,<a role="doc-backlink" href="#id1">7</a>,<a role="doc-backlink" href="#id1">8</a>,<a role="doc-backlink" href="#id10">9</a>,<a role="doc-backlink" href="#id11">10</a>,<a role="doc-backlink" href="#id12">11</a>)</span>
<p>Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. <em>PLOS Computational Biology</em>, 11(10):1–16, 10 2015. <a class="reference external" href="https://doi.org/10.1371/journal.pcbi.1004415">doi:10.1371/journal.pcbi.1004415</a>.</p>
</div>
</div>
</div>
</section>
</section>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ces</span></code>(ensembles[, select, clustering_method, ...])</p></td>
<td><p>Calculates the Clustering Ensemble Similarity (CES) between ensembles using the Jensen-Shannon divergence as described in <span id="id10">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ces_convergence</span></code>(original_ensemble, window_size)</p></td>
<td><p>Use the CES to evaluate the convergence of the ensemble/trajectory.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clustering_ensemble_similarity</span></code>(cc, ens1, ...)</p></td>
<td><p>Clustering ensemble similarity: calculate the probability densities from</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumulative_clustering_ensemble_similarity</span></code>(cc, ...)</p></td>
<td><p>Calculate clustering ensemble similarity between joined ensembles.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumulative_gen_kde_pdfs</span></code>(embedded_space, ...)</p></td>
<td><p>Generate Kernel Density Estimates (KDE) from embedded spaces and elaborate the coordinates for later use.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dimred_ensemble_similarity</span></code>(kde1, resamples1, ...)</p></td>
<td><p>Calculate the Jensen-Shannon divergence according the Dimensionality reduction method.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">discrete_jensen_shannon_divergence</span></code>(pA, pB)</p></td>
<td><p>Jensen-Shannon divergence between discrete probability distributions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">discrete_kullback_leibler_divergence</span></code>(pA, pB)</p></td>
<td><p>Kullback-Leibler divergence between discrete probability distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dres</span></code>(ensembles[, select, ...])</p></td>
<td><p>Calculates the Dimensional Reduction Ensemble Similarity (DRES) between ensembles using the Jensen-Shannon divergence as described in <span id="id11">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dres_convergence</span></code>(original_ensemble, window_size)</p></td>
<td><p>Use the DRES to evaluate the convergence of the ensemble/trajectory.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_kde_pdfs</span></code>(embedded_space, ...)</p></td>
<td><p>Generate Kernel Density Estimates (KDE) from embedded spaces and elaborate the coordinates for later use.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">harmonic_ensemble_similarity</span></code>(sigma1, sigma2, ...)</p></td>
<td><p>Calculate the harmonic ensemble similarity measure as defined in <span id="id12">[<a class="reference internal" href="#id9" title="Matteo Tiberti, Elena Papaleo, Tone Bengtsen, Wouter Boomsma, and Kresten Lindorff-Larsen. Encore: software for quantitative ensemble comparison. PLOS Computational Biology, 11(10):1-16, 10 2015. doi:10.1371/journal.pcbi.1004415.">ᵇTPB+15</a>]</span>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hes</span></code>(ensembles[, select, cov_estimator, ...])</p></td>
<td><p>Calculates the Harmonic Ensemble Similarity (HES) between ensembles.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepare_ensembles_for_convergence_increasing_window</span></code>(...)</p></td>
<td><p>Generate ensembles to be fed to ces_convergence or dres_convergence from a single ensemble.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_output</span></code>(matrix[, base_fname, header, ...])</p></td>
<td><p>Write output matrix with a nice format, to stdout and optionally a file.</p></td>
</tr>
</tbody>
</table>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mdaencore.dimensionality_reduction.stochasticproxembed.html" class="btn btn-neutral float-left" title="mdaencore.dimensionality_reduction.stochasticproxembed" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mdaencore.utils.html" class="btn btn-neutral float-right" title="mdaencore.utils" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, MDAnalysis. Project structure based on the MDAnalysis Cookiecutter version 0.1.</p>
  </div>

  

<div class="footer"><p>Please see
    our <a href="https://www.mdanalysis.org/pages/privacy/">Privacy Policy</a>
    to learn how <a href="https://www.mdanalysis.org">MDAnalysis</a> collects data.</p>
    <script data-goatcounter="https://mdanalysis.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</div>



</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
    var versions_json_url = ''
</script>

<div class="rst-versions" data-toggle="rst-versions" role="note"
     aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
        
      <span class="fa fa-caret-down"></span>
    </span>

    <div class="rst-other-versions">
        <dl id="versionselector">
            <dt>Other Versions</dt>
        </dl>

    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>